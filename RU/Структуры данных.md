# Структуры данных

# Массивы

- Доступ к элементам за O(1), по индексу
- Непрерывный кусок памяти
- Размер куска памяти фиксируется при создании
- Внутри массива элементы должны быть одного типа данных и одного размера (по памяти)
- В динамических массивах есть два способа перевыделения памяти:
    - Аддитивный - добавление какого количества памяти, Ø(n^2)
    - Мультипликативный - увеличение памяти в какое-то количество раз, Ø(n)
- Операции с массивом:
    
    
    |  | Вставка | Удаление |
    | --- | --- | --- |
    | Начало | O(n) | O(n) |
    | Конец | O(1) | O(1) |
    | Середина | O(n) | O(n) |

# Списки

- Хранится в разных местах памяти
- Каждый элемент хранит не только само значение, но и ссылку на следующий элемент (если список односвязный) или ссылку на следующий и предыдущий элемент (если список двусвязный)
- Внутри одного списка данные могут быть разных типов
- Операции со списком:
    
    
    |  | Вставка | Удаление |
    | --- | --- | --- |
    | Начало | O(1) | O(1) |
    | Конец | O(1) | O(1), если список двусвязный, O(n) при односвязном |
    | Середина | O(1), если вставка после элемента либо список двусвязный. В односвязном списке вставка перед элементом за O(n) | O(1), если список двусвязный, O(n) при односвязном |

# Стек

- Является абстрактной структурой данных, реализованной через интерфейс (методы)
- Имеет несколько обязательных методов:
    - push - добавить элемент наверх, O(1)
    - top - получить значение верхнего элемента, O(1)
    - pop - снять верхний элемент, O(1)

# Очередь

- Является абстрактной структурой данных, реализованной через интерфейс (методы)
- Имеет несколько обязательных методов:
    - enqueue - добавить элемент в начало, O(1)
    - dequeue - убрать элемент с конца, O(1)

# Деревья

- Неориентированный связный граф без циклов
- Если в дереве N вершин, то обязательно N-1 ребро
- Между любыми двумя вершинами есть только один путь (ребро)
- В структурах данных как правило используются корневые деревья - деревья,  у которых одна из вершин объявлена корнем, а следовательно есть внутри дерева есть родители и дети, возникает иерархия

| Характеристика | Описание |
| --- | --- |
| Выделение памяти | В каждом узле дерева хранится информация о его дочерних узлах. Для представления корневого дерева в памяти используются структуры данных, такие как массивы, списки или указатели. Обычно память выделяется для каждого узла и его дочерних узлов отдельно. |
| Добавление узла | Добавление нового узла к корневому дереву обычно требует выделения памяти под новый узел и его связывание с существующим узлом (родителем). Время добавления узла зависит от специфики реализации и может быть O(1) до O(log n), где n - количество узлов в дереве. |
| Удаление узла | При удалении узла из корневого дерева также требуется управление памятью и перестройка структуры дерева. Время удаления узла зависит от специфики реализации и может быть O(1) до O(log n). |
| Поиск узла | Поиск узла в корневом дереве может осуществляться путем обхода дерева в глубину или в ширину. Время поиска зависит от размера и структуры дерева и может быть в худшем случае O(n), где n - количество узлов в дереве. |
| Глубина дерева | Глубина корневого дерева определяется как максимальное количество уровней в дереве от корня до самого удаленного листа. Глубина дерева может быть в худшем случае O(n), где n - количество узлов в дереве, если дерево несбалансировано. |
| Высота дерева | Высота корневого дерева определяется как максимальная длина пути от корня до любого листового узла. Высота дерева может быть в худшем случае O(n), где n - количество узлов в дереве, если дерево несбалансировано. |

P.S. В данном контексте высота и глубина означают одно и то же. А вообще глубина может считаться от конкретно узла до корня и не быть равной высоте, если дерево несбалансировано. Иными словами, высота дерева - это максимально возможная глубина.

# Хэш-таблицы

- Хэш - это числовое значение фиксированной длины. Оно вычисляется из произвольного набора данных с использованием хэш-функции. Обычно хэш представлен в виде последовательности байт или шестнадцатеричного числа. Количество битов в хэш-значении зависит от используемой хэш-функции. Например, для хэш-функции SHA-256, хэш будет состоять из 256 битов, что эквивалентно 64 шестнадцатеричным символам или 32 байтам.
- Доступ к элементам в среднем за O(1), но в худшем случае может быть O(n)
- Данные хранятся в виде пар "ключ-значение", но иногда к них хранится и дополнительная информация (например статус - занята или свободна ячейка)
- Размер хэш-таблицы может динамически изменяться в зависимости от количества элементов
- Память выделяется не непрерывным блоком, а в виде массива "корзин" (buckets), каждая из которых может содержать несколько элементов
- Внутри хэш-таблицы элементы могут быть разного типа данных
- Реализация перевыделения памяти зависит от конкретной реализации хэш-таблицы и используемого алгоритма хеширования
- Операции с хэш-таблицей:
    
    
    |  | Вставка | Удаление |
    | --- | --- | --- |
    | Лучший случай | O(1) | O(1) |
    | Худший случай | O(n) | O(n) |

### Способы разрешения коллизий в хэш-таблицах

1. **Открытая адресация (Open Addressing)**:
    - В этом методе элементы хранятся непосредственно в самой таблице, а не в связанных списках или других структурах данных.
    - При возникновении коллизии происходит поиск следующей доступной ячейки (по определенному алгоритму) и помещение элемента туда.
    - Примеры:, Quadratic Probing, Double Hashing:
        - Linear Probing - если ячейка занята, то просто продолжаем последовательно перебирать индексы следующих ячеек, пока не найдём свободную. Может возникнуть проблема кластеризации, а также если таблица заполнена даже на 50%, то уже будет работать достаточно неэффективно.
        - Quadratic Probing - суть, как при линейном пробировании, но поиск индекса новой ячейки идёт не как $currentIndex + i$, а как $currentIndex + i^2$. Такой подход убирает проблемы линейного пробирования, да и в целом работает эффективнее.
        - Double hashing выглядит следующим образом:
            1. Первая хеш-функция используется для вычисления исходного индекса для ключа.
            2. Если этот индекс уже занят, применяется вторая хеш-функция для вычисления шага (инкремента), на который нужно сдвинуться от исходного индекса.
            3. Полученный инкремент добавляется к исходному индексу, и таким образом получается новый индекс для пробирования.
            4. Если и новый индекс уже занят, процесс повторяется с использованием второй хеш-функции для вычисления нового шага.
2. **Закрытая адресация (Closed Addressing)**:
    - В этом методе каждая ячейка хэш-таблицы содержит список элементов, которые имеют одинаковый хэш-код.
    - При возникновении коллизии новый элемент добавляется в соответствующий список. Каждый список содержит пары ключ-значение, чтобы понимать, какой именно
    - Пример: Chaining (цепочки):
        1. Когда ключ хэшируется, полученный хеш используется для определения индекса в хэш-таблице.
        2. Если по этому индексу уже есть элементы, новый элемент добавляется в конец связанного списка, соответствующего этому индексу.
        3. Если по этому индексу пока нет элементов, новый элемент становится первым в списке.
        
        Преимущества метода цепочек:
        
        - Прост в реализации.
        - Позволяет хранить любое количество элементов, так как каждая ячейка хранит связанный список.
        - Эффективен в случае, когда количество коллизий невелико.
        
        Недостатки метода цепочек:
        
        - Может занимать больше памяти, чем другие методы, из-за необходимости хранить дополнительные связанные списки.
        - Не так эффективен в случае большого количества коллизий, что может привести к увеличению времени доступа к элементам списка.